#pragma once
#ifndef LCD_CANVAS_H
#define LCD_CANVAS_H

#include "I_LCD_HAL.h"
#include "DSP/Math.h"
#include "DSP/Debug.h"

class LCDCanvas
{
public:
	LCDCanvas(void)
		: m_HAL(nullptr),
		  m_CharacterSpacing(0),
		  m_LineSpacing(0)
	{
	}

	void Initialize(I_LCD_HAL *HAL)
	{
		ASSERT(HAL != nullptr, "HAL cannot be null");

		m_HAL = HAL;
	}

	void Clear(Color Color)
	{
		ASSERT(m_HAL != nullptr, "m_HAL cannot be null");

		m_HAL->Clear(Color);
	}

	void DrawPixel(uint16 X, uint16 Y, Color Color)
	{
		ASSERT(m_HAL != nullptr, "m_HAL cannot be null");

		m_HAL->DrawPixel({X, Y}, Color);
	}

	void DrawLine(uint16 X0, uint16 Y0, uint16 X1, uint16 Y1, Color Color, uint8 Thickness = 1)
	{
		if (X0 == X1)
		{
			DrawVerticalLine(X0, Y0, Y1 - Y0 + 1, Color, Thickness);

			return;
		}

		if (Y0 == Y1)
		{
			DrawHorizontalLine(X0, Y0, X1 - X0 + 1, Color, Thickness);

			return;
		}

		for (uint8 t = 0; t < Thickness; ++t)
		{
			int16 x0 = (X0 - Thickness / 2) + t;
			int16 x1 = (X1 - Thickness / 2) + t;
			int16 y0 = Y0;

			int32 deltaX = Math::Absolute((int16)x1 - (int16)x0);
			int32 deltaY = Math::Absolute((int16)Y1 - (int16)Y0);
			int32 signX = Math::Sign((int16)x1 - (int16)x0);
			int32 signY = Math::Sign((int16)Y1 - (int16)Y0);
			int32 error = deltaX - deltaY;

			DrawPixel(x1, Y1, Color);

			while ((x0 != x1) || (y0 != Y1))
			{
				DrawPixel(x0, y0, Color);

				int32 error2 = error * 2;

				if (error2 > -deltaY)
				{
					error -= deltaY;
					x0 += signX;
				}

				if (error2 < deltaX)
				{
					error += deltaX;
					y0 += signY;
				}
			}
		}
	}

	void DrawRectangle(uint16 X, uint16 Y, uint16 Width, uint16 Height, Color Color, uint8 Thickness = 1)
	{
		int32 x2 = X + Width;
		int32 y2 = Y + Height;

		DrawLine(X, Y, X, y2, Color, Thickness);
		DrawLine(X, Y, x2, Y, Color, Thickness);
		DrawLine(X, y2, x2, y2, Color, Thickness);
		DrawLine(x2, Y, x2, y2, Color, Thickness);
	}

	void DrawFilledRectangle(uint16 X, uint16 Y, uint16 Width, uint16 Height, Color Color)
	{
		for (uint32 j = 0; j < Height; ++j)
			for (uint32 i = 0; i < Width; ++i)
				DrawPixel(X + i, Y + j, Color);
	}

	void DrawParallelogram(uint16 LeftTopX, uint16 LeftTopY, uint16 LeftBottomX, uint16 LeftBottomY, uint16 RightTopX, uint16 RightTopY, uint16 RightBottomX, uint16 RightBottomY, Color Color, uint8 Thickness = 1)
	{
		DrawLine(LeftTopX, LeftTopY, LeftBottomX, LeftBottomY, Color, Thickness);
		DrawLine(LeftTopX, LeftTopY, RightTopX, RightTopY, Color, Thickness);
		DrawLine(RightTopX, RightTopY, RightBottomX, RightBottomY, Color, Thickness);
		DrawLine(LeftBottomX, LeftBottomY, RightBottomX, RightBottomY, Color, Thickness);
	}

	void DrawFilledParallelogram(uint16 LeftTopX, uint16 LeftTopY, uint16 LeftBottomX, uint16 LeftBottomY, uint16 RightTopX, uint16 RightTopY, uint16 RightBottomX, uint16 RightBottomY, Color Color)
	{
		uint16 minX = LeftTopX;
		uint16 minY = LeftTopY;

		uint16 maxX = RightBottomX;
		uint16 maxY = RightBottomY;

		// TODO: Handle the middle point
		if (LeftTopX != LeftBottomX)
		{
			minX = Math::Max(LeftTopX, LeftBottomX);

			DrawFilledTriangle(LeftTopX, LeftTopY, LeftTopX, LeftBottomY, LeftBottomX, LeftBottomY, Color);
		}

		// TODO: Handle the middle point
		if (LeftTopY != RightTopY)
		{
			minY = Math::Max(LeftTopY, RightTopY);

			DrawFilledTriangle(LeftTopX, LeftTopY, LeftTopX, RightTopY, RightBottomX, RightBottomY, Color);
		}

		if (RightTopX != RightBottomX)
		{
			maxX = Math::Min(RightTopX, RightBottomX);

			uint16 y2 = RightBottomY;
			if (RightTopX > RightBottomX)
				y2 = RightTopY;

			DrawFilledTriangle(RightTopX, RightTopY, maxX, y2, RightBottomX, RightBottomY, Color);
		}

		// TODO: Handle the middle point
		if (LeftBottomY != RightBottomY)
		{
			maxY = Math::Min(LeftBottomY, RightBottomY);

			DrawFilledTriangle(LeftBottomX, LeftBottomY, LeftBottomX, RightBottomY, RightBottomX, RightBottomY, Color);
		}

		DrawFilledRectangle(minX, minY, maxX - minX, maxY - minY, Color);
	}

	void DrawTriangle(uint16 X0, uint16 Y0, uint16 X1, uint16 Y1, uint16 X2, uint16 Y2, Color Color, uint8 Thickness = 1)
	{
		DrawLine(X0, Y0, X1, Y1, Color, Thickness);
		DrawLine(X1, Y1, X2, Y2, Color, Thickness);
		DrawLine(X2, Y2, X0, Y0, Color, Thickness);
	}

	void DrawFilledTriangle(uint16 X0, uint16 Y0, uint16 X1, uint16 Y1, uint16 X2, uint16 Y2, Color Color)
	{
		int16 a, b, y, last;

		// Sort coordinates by Y order (y2 >= y1 >= y0)
		if (Y0 > Y1)
		{
			std::swap(Y0, Y1);
			std::swap(X0, X1);
		}
		if (Y1 > Y2)
		{
			std::swap(Y2, Y1);
			std::swap(X2, X1);
		}
		if (Y0 > Y1)
		{
			std::swap(Y0, Y1);
			std::swap(X0, X1);
		}

		if (Y0 == Y2)
		{
			// Handle awkward all-on-same-line case as its own thing
			a = b = X0;

			if (X1 < a)
				a = X1;
			else if (X1 > b)
				b = X1;

			if (X2 < a)
				a = X2;
			else if (X2 > b)
				b = X2;

			DrawHorizontalLine(a, Y0, b - a + 1, Color);

			return;
		}

		int16 dx01 = X1 - X0, dy01 = Y1 - Y0, dx02 = X2 - X0, dy02 = Y2 - Y0,
			  dx12 = X2 - X1, dy12 = Y2 - Y1;
		int32 sa = 0, sb = 0;

		// For upper part of triangle, find scanline crossings for segments
		// 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
		// is included here (and second loop will be skipped, avoiding a /0
		// error there), otherwise scanline y1 is skipped here and handled
		// in the second loop...which also avoids a /0 error here if y0=y1
		// (flat-topped triangle).
		if (Y1 == Y2)
		{
			last = Y1; // Include y1 scanline
		}
		else
		{
			last = Y1 - 1; // Skip it
		}

		for (y = Y0; y < last; ++y)
		{
			a = X0 + sa / dy01;
			b = X0 + sb / dy02;
			sa += dx01;
			sb += dx02;
			/* longhand:
			a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
			b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
			*/
			if (a > b)
			{
				std::swap(a, b);
			}

			DrawHorizontalLine(a, y, b - a + 1, Color);
		}

		// For lower part of triangle, find scanline crossings for segments
		// 0-2 and 1-2.  This loop is skipped if y1=y2.
		sa = (int32)dx12 * (y - Y1);
		sb = (int32)dx02 * (y - Y0);
		for (; y < Y2; ++y)
		{
			a = X1 + sa / dy12;
			b = X0 + sb / dy02;
			sa += dx12;
			sb += dx02;
			/* longhand:
				a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
				b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
			*/
			if (a > b)
			{
				std::swap(a, b);
			}

			DrawHorizontalLine(a, y, b - a + 1, Color);
		}
	}

	void DrawCircle(uint16 X0, uint16 Y0, uint16 Radius, Color Color, uint8 Thickness = 1)
	{
		--Radius;

		for (int16 r = -Thickness / 2; r < Thickness; ++r)
		{
			int16 radius = Radius + r;

			int16 f = 1 - radius;
			int16 ddF_x = 1;
			int16 ddF_y = -2 * radius;
			int16 x = 0;
			int16 y = radius;

			DrawPixel(X0, Y0 + radius, Color);
			DrawPixel(X0, Y0 - radius, Color);
			DrawPixel(X0 + radius, Y0, Color);
			DrawPixel(X0 - radius, Y0, Color);

			while (x < y)
			{
				if (f >= 0)
				{
					y--;
					ddF_y += 2;
					f += ddF_y;
				}
				x++;
				ddF_x += 2;
				f += ddF_x;

				DrawPixel(X0 + x, Y0 + y, Color);
				DrawPixel(X0 - x, Y0 + y, Color);
				DrawPixel(X0 + x, Y0 - y, Color);
				DrawPixel(X0 - x, Y0 - y, Color);
				DrawPixel(X0 + y, Y0 + x, Color);
				DrawPixel(X0 - y, Y0 + x, Color);
				DrawPixel(X0 + y, Y0 - x, Color);
				DrawPixel(X0 - y, Y0 - x, Color);
			}
		}
	}

	void DrawFilledCircle(uint16 X0, uint16 Y0, uint16 Radius, Color Color)
	{
		--Radius;

		DrawLine(X0, Y0 - Radius, X0, Y0 + Radius + 1, Color);

		const uint8 CORNER_NAME = 3;

		int16 f = 1 - Radius;
		int16 ddF_x = 1;
		int16 ddF_y = -2 * Radius;
		int16 x = 0;
		int16 y = Radius;

		uint16 delta = 0;

		delta++;

		while (x < y)
		{
			if (f >= 0)
			{
				y--;
				ddF_y += 2;
				f += ddF_y;
			}
			x++;
			ddF_x += 2;
			f += ddF_x;

			if (CORNER_NAME & 0x1)
			{
				DrawLine(X0 + x, Y0 - y, X0 + x, Y0 - y + 2 * y + delta - 1, Color);
				DrawLine(X0 + y, Y0 - x, X0 + y, Y0 - x + 2 * x + delta - 1, Color);
			}

			if (CORNER_NAME & 0x2)
			{
				DrawLine(X0 - x, Y0 - y, X0 - x, Y0 - y + 2 * y + delta - 1, Color);
				DrawLine(X0 - y, Y0 - x, X0 - y, Y0 - x + 2 * x + delta - 1, Color);
			}
		}
	}

	// https://www.cambridgeincolour.com/tutorials/image-interpolation.htm
	void DrawCharacter(uint16 X, uint16 Y, char Char, const Font &Font, Color Color)
	{
		const uint8 MAX_SCALED_SIZE = 128;

		ASSERT(Font.Height * Font.Scale <= MAX_SCALED_SIZE, "Running out of max scaled size");

		if (Char < ' ' || '~' < Char)
			return;

		uint8 alphaMap[MAX_SCALED_SIZE * MAX_SCALED_SIZE] = {};
#define ALPHA_VALUE(IndexX, IndexY) alphaMap[(uint8)(IndexX) + ((uint8)(IndexY) * newWidth)]

		uint8 newWidth = Font.Width * Font.Scale;
		uint8 newHeight = Font.Height * Font.Scale;

		uint8 charIndex = Char - ' ';
		auto dataPtr = Font.Data + (charIndex * Font.Height);
		for (uint8 y = 0; y < Font.Height; ++y)
		{
			uint16 data = dataPtr[y];

			for (uint8 x = 0; x < Font.Width; ++x)
				ALPHA_VALUE(x * Font.Scale, y * Font.Scale) = (((1 << x) & data) == 0 ? 0 : 255);
		}

		// if (Font.Scale != 1)
		// 	for (uint8 y = 0; y < newHeight; ++y)
		// 		for (uint8 x = 0; x < newWidth; ++x)
		// 		{
		// 			uint8 value = ALPHA_VALUE(x, y);
		// 			if (value == 255)
		// 				continue;

		// 			uint16 sum = 0;
		// 			sum += (x == 0 ? 0 : ALPHA_VALUE(x - 1, y));
		// 			sum += (x + 1 == newWidth ? 0 : ALPHA_VALUE(x + 1, y));
		// 			sum += (y == 0 ? 0 : ALPHA_VALUE(x, y - 1));
		// 			sum += (y + 1 == newWidth ? 0 : ALPHA_VALUE(x, y + 1));

		// 			uint8 avg = sum / 4;

		// 			ALPHA_VALUE(x, y) = avg * 1.5;
		// 		}

		for (uint8 y = 0; y < newHeight; ++y)
			for (uint8 x = 0; x < newWidth; ++x)
			{
				uint8 alpha = ALPHA_VALUE(x, y);
				if (alpha == 0)
					continue;

				DrawPixel(X + x, Y + y, {Color.R, Color.G, Color.B, alpha});
			}

#undef ALPHA_VALUE
	}

	void DrawString(uint16 X, uint16 Y, cstr const String, const Font &Font, Color Color)
	{
		DrawString(X, Y, String, GetStringLength(String), Font, Color);
	}

	void DrawString(uint16 X, uint16 Y, cstr String, uint16 Length, const Font &Font, Color Color)
	{
		ASSERT(String != nullptr, "String cannot be null");

		if (Length == 0)
			return;

		uint16 x = X;

		for (uint16 i = 0; i < Length; ++i)
		{
			char ch = String[i];

			if (ch == '\n' || ch == '\r')
			{
				Y += (Font.Height * Font.Scale) + m_LineSpacing;
				x = X;
				continue;
			}

			DrawCharacter(x, Y, ch, Font, Color);

			x += (Font.Width * Font.Scale) + m_CharacterSpacing;
		}
	}

	Point MeasureCharacterDimension(char Character, const Font &Font)
	{
		if (Character == '\n' || Character == '\r')
			return {};

		return {(Font.Width * Font.Scale) + m_CharacterSpacing, (Font.Height * Font.Scale) + m_LineSpacing};
	}

	Point MeasureStringDimension(cstr String, const Font &Font)
	{
		return MeasureStringDimension(String, GetStringLength(String), Font);
	}

	Point MeasureStringDimension(cstr String, uint16 Length, const Font &Font)
	{
		ASSERT(String != nullptr, "String cannot be null");

		if (Length == 0)
			return {};

		uint16 maxCharCountPerLine = 0;
		uint16 charCount = 0;
		uint16 lineCount = 1;
		for (uint16 i = 0; i < Length; ++i)
		{
			char ch = String[i];

			if (ch == '\n' || ch == '\r')
			{
				++lineCount;
				charCount = 0;

				continue;
			}

			++charCount;

			if (maxCharCountPerLine < charCount)
				maxCharCountPerLine = charCount;
		}

		return {((Font.Width * Font.Scale) + m_CharacterSpacing) * maxCharCountPerLine, ((Font.Height * Font.Scale) + m_LineSpacing) * lineCount};
	}

	void DrawPixel(Point Position, Color Color)
	{
		DrawPixel(Position.X, Position.Y, Color);
	}

	void DrawLine(Point Position0, Point Position1, Color Color, uint8 Thickness = 1)
	{
		DrawLine(Position0.X, Position0.Y, Position1.X, Position1.Y, Color, Thickness);
	}

	void DrawRectangle(Rect Rect, Color Color, uint8 Thickness = 1)
	{
		DrawRectangle(Rect.Position.X, Rect.Position.Y, Rect.Dimension.X, Rect.Dimension.Y, Color, Thickness);
	}

	void DrawFilledRectangle(Rect Rect, Color Color)
	{
		DrawFilledRectangle(Rect.Position.X, Rect.Position.Y, Rect.Dimension.X, Rect.Dimension.Y, Color);
	}

	void DrawParallelogram(Point LeftTop, Point LeftBottom, Point RightTop, Point RightBottom, Color Color, uint8 Thickness = 1)
	{
		DrawParallelogram(LeftTop.X, LeftTop.Y, LeftBottom.X, LeftBottom.Y, RightTop.X, RightTop.Y, RightBottom.X, RightBottom.Y, Color, Thickness);
	}

	void DrawFilledParallelogram(Point LeftTop, Point LeftBottom, Point RightTop, Point RightBottom, Color Color)
	{
		DrawFilledParallelogram(LeftTop.X, LeftTop.Y, LeftBottom.X, LeftBottom.Y, RightTop.X, RightTop.Y, RightBottom.X, RightBottom.Y, Color);
	}

	void DrawTriangle(Point Position0, Point Position1, Point Position2, Color Color, uint8 Thickness = 1)
	{
		DrawTriangle(Position0.X, Position0.Y, Position1.X, Position1.Y, Position2.X, Position2.Y, Color, Thickness);
	}

	void DrawFilledTriangle(Point Position0, Point Position1, Point Position2, Color Color)
	{
		DrawFilledTriangle(Position0.X, Position0.Y, Position1.X, Position1.Y, Position2.X, Position2.Y, Color);
	}

	void DrawCircle(Point Position, uint16 Radius, Color Color, uint8 Thickness = 1)
	{
		DrawCircle(Position.X, Position.Y, Radius, Color, Thickness);
	}

	void DrawFilledCircle(Point Position, uint16 Radius, Color Color)
	{
		DrawFilledCircle(Position.X, Position.Y, Radius, Color);
	}

	void DrawCharacter(Point Position, char Char, const Font &Font, Color Color)
	{
		DrawCharacter(Position.X, Position.Y, Char, Font, Color);
	}

	void DrawString(Point Position, cstr String, const Font &Font, Color Color)
	{
		DrawString(Position.X, Position.Y, String, Font, Color);
	}

	void DrawString(Point Position, cstr String, uint16 Length, const Font &Font, Color Color)
	{
		DrawString(Position.X, Position.Y, String, Length, Font, Color);
	}

	void SetStringSpacing(int8 Character, int8 Line)
	{
		m_CharacterSpacing = Character;
		m_LineSpacing = Line;
	}

	const Point &GetDimension(void) const
	{
		return m_HAL->GetDimension();
	}

private:
	void DrawVerticalLine(uint16 X, uint16 Y, int16 Height, Color Color, uint8 Thickness = 1)
	{
		int16 x = X - (Thickness / 2);

		if (Height < 0)
		{
			Y = Math::Max(0, Y + Height);
			Height *= -1;
		}

		for (uint8 tX = 0; tX < Thickness; ++tX)
			for (uint16 i = Y; i < Y + Height; ++i)
				DrawPixel(x + tX, i, Color);
	}

	void DrawHorizontalLine(uint16 X, uint16 Y, int16 Width, Color Color, uint8 Thickness = 1)
	{
		int16 y = Y - (Thickness / 2);

		if (Width < 0)
		{
			X = Math::Max(0, X + Width);
			Width *= -1;
		}

		for (uint8 tY = 0; tY < Thickness; ++tY)
			for (uint16 i = X; i < X + Width; ++i)
				DrawPixel(i, y + tY, Color);
	}

private:
	I_LCD_HAL *m_HAL;
	int8 m_CharacterSpacing;
	int8 m_LineSpacing;
};

static constexpr uint16 DUBAI_BOLD_16_DATA[] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [ ]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0002, 0x0000, // [!]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0012, 0x0012, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ["]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0040, 0x0044, 0x0004, 0x0004, 0x0024, 0x0024, 0x007E, 0x0020, 0x0002, // [#]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0010, 0x0010, 0x0044, 0x0002, 0x0006, 0x001C, 0x0020, 0x0040, 0x0040, 0x0042, 0x0018, // [$]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0010, 0x0000, 0x0000, // [%]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x003C, 0x003C, 0x003C, 0x0018, 0x001C, 0x013E, 0x00FE, 0x01FE, 0x0008, // [&]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [']
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0004, 0x0004, 0x0004, 0x0006, 0x0002, 0x0006, 0x0004, 0x0004, 0x0000, // [(]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0000, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0000, 0x0004, // [)]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [*]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0010, 0x007E, 0x0010, 0x0010, 0x0000, // [+]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, // [,]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [-]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, // [.]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0040, 0x0020, 0x0020, 0x0000, 0x0010, 0x0010, 0x0000, 0x0008, 0x0008, 0x0004, 0x0004, // [/]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0024, 0x0042, 0x0042, 0x0042, 0x0042, 0x0042, 0x0042, 0x0024, 0x0008, // [0]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0018, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x007C, // [1]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0024, 0x0060, 0x0040, 0x0020, 0x0000, 0x0010, 0x0008, 0x0004, 0x007E, // [2]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0024, 0x0020, 0x0020, 0x0010, 0x0020, 0x0000, 0x0040, 0x0020, 0x001C, // [3]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0008, 0x0004, 0x0024, 0x0020, 0x0022, 0x0020, 0x0020, 0x0020, // [4]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x003C, 0x0004, 0x0004, 0x001C, 0x0020, 0x0040, 0x0040, 0x0020, 0x001C, // [5]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0004, 0x0000, 0x003E, 0x0042, 0x0042, 0x0042, 0x0044, 0x0010, // [6]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007E, 0x0020, 0x0000, 0x0010, 0x0000, 0x0008, 0x0008, 0x0008, 0x0004, // [7]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0024, 0x0044, 0x0004, 0x0018, 0x0020, 0x0042, 0x0042, 0x0042, 0x0018, // [8]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0024, 0x0042, 0x0042, 0x0042, 0x0064, 0x0040, 0x0000, 0x0000, 0x000C, // [9]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, // [:]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, // [;]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0006, 0x0002, 0x0018, 0x0000, 0x0000, // [<]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007E, 0x0000, 0x0000, 0x007E, 0x0000, 0x0000, // [=]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0018, 0x0060, 0x0040, 0x0010, 0x0004, 0x0000, // [>]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0022, 0x0020, 0x0020, 0x0010, 0x0008, 0x0000, 0x0000, 0x0008, 0x0008, // [?]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0040, 0x0040, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [@]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0030, 0x0040, 0x0048, 0x0048, 0x0084, 0x00FC, 0x0084, 0x0102, 0x0102, // [A]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0064, 0x0084, 0x0004, 0x0024, 0x0044, 0x0084, 0x0084, 0x0044, 0x001C, // [B]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0058, 0x0004, 0x0006, 0x0002, 0x0002, 0x0006, 0x0004, 0x000C, 0x0078, // [C]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007C, 0x0084, 0x0104, 0x0104, 0x0104, 0x0104, 0x0084, 0x0044, 0x000C, // [D]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007C, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x007C, // [E]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007C, 0x0004, 0x0004, 0x0004, 0x003C, 0x0004, 0x0004, 0x0004, 0x0004, // [F]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0098, 0x0004, 0x0004, 0x0002, 0x01E2, 0x0186, 0x0184, 0x018C, 0x0070, // [G]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0104, 0x0104, 0x0104, 0x0104, 0x01FC, 0x0104, 0x0104, 0x0104, 0x0104, // [H]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, // [I]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0010, 0x000E, // [J]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0084, 0x0044, 0x0024, 0x0014, 0x0014, 0x0024, 0x0044, 0x0084, 0x0184, // [K]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x007C, // [L]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0404, 0x060C, 0x0504, 0x0514, 0x0484, 0x04A4, 0x0444, 0x0404, 0x0404, // [M]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x010C, 0x010C, 0x0114, 0x0124, 0x0124, 0x0144, 0x0184, 0x0184, 0x0104, // [N]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x00D8, 0x0104, 0x0304, 0x0202, 0x0202, 0x0206, 0x0104, 0x0088, 0x0030, // [O]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007C, 0x00C4, 0x0084, 0x00C4, 0x007C, 0x0004, 0x0004, 0x0004, 0x0004, // [P]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x00D8, 0x0104, 0x0304, 0x0202, 0x0202, 0x0202, 0x0104, 0x0088, 0x00E0, // [Q]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007C, 0x0044, 0x0084, 0x0044, 0x003C, 0x0024, 0x0004, 0x0044, 0x0084, // [R]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0044, 0x0002, 0x0004, 0x001C, 0x0060, 0x0040, 0x0040, 0x0046, 0x003C, // [S]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00FE, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, // [T]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0106, 0x0106, 0x0106, 0x0106, 0x0106, 0x0104, 0x0104, 0x008C, 0x0030, // [U]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0102, 0x0084, 0x0084, 0x0084, 0x0048, 0x0048, 0x0000, 0x0030, 0x0030, // [V]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x10C2, 0x1002, 0x0804, 0x0924, 0x0924, 0x0924, 0x0008, 0x0618, 0x0618, // [W]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0048, 0x0028, 0x0030, 0x0030, 0x0008, 0x0040, 0x0084, 0x0082, // [X]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0084, 0x0044, 0x0048, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, // [Y]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x007E, 0x0040, 0x0020, 0x0010, 0x0000, 0x0008, 0x0004, 0x0004, 0x00FE, // [Z]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001C, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, // [[]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0004, 0x0004, 0x0000, 0x0008, 0x0008, 0x0000, 0x0010, 0x0010, 0x0020, 0x0020, // [\]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x000E, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, // []]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [^]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [_]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [`]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0018, 0x0020, 0x0020, 0x0030, 0x0020, 0x0022, 0x0024, // [a]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0022, 0x0006, 0x0042, 0x0042, 0x0042, 0x0022, 0x001C, // [b]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0004, 0x0002, 0x0002, 0x0002, 0x0004, 0x0008, // [c]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0040, 0x0040, 0x0040, 0x0050, 0x0044, 0x0042, 0x0042, 0x0042, 0x0044, 0x0048, // [d]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0024, 0x0022, 0x003E, 0x0002, 0x0004, 0x0018, // [e]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0018, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, // [f]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0030, 0x0020, 0x0002, 0x0020, 0x0004, 0x0000, 0x003C, // [g]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0022, 0x0006, 0x0042, 0x0042, 0x0042, 0x0042, 0x0042, // [h]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, // [i]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, // [j]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0022, 0x0012, 0x0012, 0x0012, 0x0022, 0x0042, // [k]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, // [l]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0200, 0x0066, 0x0442, 0x0442, 0x0442, 0x0442, 0x0442, // [m]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0006, 0x0042, 0x0042, 0x0042, 0x0042, 0x0042, // [n]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0042, 0x0042, 0x0042, 0x0000, 0x0018, // [o]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0006, 0x0042, 0x0042, 0x0042, 0x0022, 0x001E, // [p]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0044, 0x0042, 0x0042, 0x0042, 0x0040, 0x0048, // [q]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001E, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, // [r]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x000C, 0x0000, 0x0020, 0x001C, // [s]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0008, // [t]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0042, 0x0042, 0x0042, 0x0042, 0x0044, 0x0040, // [u]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0022, 0x0020, 0x0004, 0x0014, 0x0018, 0x0008, // [v]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0022, 0x0112, 0x0140, 0x0144, 0x008C, 0x0088, // [w]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0024, 0x0000, 0x0018, 0x0010, 0x0024, 0x0022, // [x]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0022, 0x0022, 0x0024, 0x0014, 0x0018, 0x0018, // [y]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0000, 0x0008, 0x0004, 0x0004, 0x003E, // [z]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0002, 0x0004, 0x0004, 0x0004, 0x0004, // [{]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // [|]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, // [}]
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0000, 0x0000, 0x0000, 0x0000, // [~]
};

static constexpr Font Font_DUBAI_BOLD_16 = {14, 16, DUBAI_BOLD_16_DATA, 1};

#endif